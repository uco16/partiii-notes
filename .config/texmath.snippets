# Snippets that use isMath()

global !p
texMathZones = ['texMathZone'+x for x in ['A', 'AS', 'B', 'BS', 'C', 'CS', 'D', 'DS', 'V', 'W', 'X', 'Y', 'Z']]
# If you have http://www.drchip.org/astronaut/vim/vbafiles/amsmath.vba.gz,
# you want to add:
texMathZones += ['texMathZone'+x for x in ['E', 'ES', 'F', 'FS', 'G', 'GS', 'H', 'HS', 'I', 'IS', 'J', 'JS', 'K', 'KS', 'L', 'LS']]
texIgnoreMathZones = ['texMathText']

texMathZoneIds = vim.eval('map('+str(texMathZones)+", 'hlID(v:val)')")
texIgnoreMathZoneIds = vim.eval('map('+str(texIgnoreMathZones)+", 'hlID(v:val)')")

def isMath():
    synstackids = vim.eval("synstack(line('.'), col('.') - (col('.')>=2 ? 1 : 0))")
    if not set(texIgnoreMathZoneIds).isdisjoint(synstackids):
        return False
    return not set(texMathZoneIds).isdisjoint(synstackids)
    # isdisjoint() can short-circuit as soon as a match is found
endglobal

priority 100

# Textmode synippets requiring isMath()

snippet ^ "Textmode Superscript" "not isMath()" eAi
\textsuperscript{${1:${VISUAL}}}$0
endsnippet

# Mathmode snippets

# dots
priority 100
#snippet ... "dots" A
#\dots
#endsnippet

snippet ... "dots" A
\dots
endsnippet

snippet +- "plus minus" Aw
\pm
endsnippet

snippet // "fraction" "isMath()" eAi
\frac{${1:${VISUAL:1}}}{${2:2}}$0
endsnippet

# --- (in)equalities ---
snippet == "alignment equation" "isMath()" eA
&=
endsnippet

snippet ^= "stacking something on equality" "isMath()" eA
\stackrel{$1}{=}$0
endsnippet

snippet != "does not equal" "isMath()" eA
\neq
endsnippet

snippet <= "less than or equal" "isMath()" eA
\leq
endsnippet

snippet >= "greater than or equal" "isMath()" eAw
\geq
endsnippet

snippet >> "much greater than" "isMath()" eA
\gg
endsnippet

snippet << "much less than" "isMath()" eA
\ll
endsnippet

snippet ~ "order of" "isMath()" eA
\sim
endsnippet

snippet def "defined to be" "isMath()" eAw
\coloneqq
endsnippet

snippet set "set" "isMath()" eAw
\\{$1\\}$0
endsnippet

snippet span "span" "isMath()" eAw
\text{Span}_{\mathbb{${1:R}}}\left\\{$2\right\\}$0
endsnippet

snippet map "Function Definition" b
\begin{equation}
	\begin{gathered}
		${1:f} \colon \\\\
		\qquad
	\end{gathered}
	\begin{gathered}
		${2:domain} \\\\
		${4:member}
	\end{gathered}
	\quad
	\begin{gathered}
		\to \\\\
		\mapsto
	\end{gathered}
	\quad
	\begin{gathered}
		${3:codomain} \\\\
		${5:image of member}
	\end{gathered}
\end{equation}$0
endsnippet

snippet sub "subscipt text" "isMath()" ei
_{\text{$1}}$0
endsnippet

#snippet hal "one half" "isMath()" eAw
#\frac{1}{2}
#endsnippet

snippet int "Integration" "isMath()" ew
\int_{${1:-\infty}}^{${2:\infty}}${VISUAL}\\$3dd[${4:d}]{${5:x}} $0
endsnippet

snippet ppp "momentum" "isMath()" eiA
_{\vb{p}}
endsnippet

snippet ppi "momentum" "isMath()" eiA
_{\vb{p}'}
endsnippet

snippet qqq "momentum" "isMath()" eiA
_{\vb{q}}
endsnippet

snippet qqi "momentum" "isMath()" eiA
_{\vb{q}'}
endsnippet

snippet 'kk(\d)' "labeled momentum" "isMath()" eiAr
_{\vb{k}_`!p snip.rv=match.group(1)`}
endsnippet

snippet 'pp(\d)' "labeled momentum" "isMath()" eiAr
_{\vb{p}_`!p snip.rv=match.group(1)`}
endsnippet

snippet wick "wick contraction" "isMath()" eAw
\wick{\c$1 \c$2}
endsnippet

snippet bdel "normalised delta" "isMath()" eAw
\bdelta^${1:4}($2)
endsnippet

priority 50

snippet under "underbrace" "isMath()" eAw
\underbrace{${1:${VISUAL}}}_{\mathclap{$2}}
endsnippet

snippet over "overbrace" "isMath()" eAw
\overbrace{${1:${VISUAL}}}^{\mathclap{$2}}
endsnippet

snippet __ "subscript" "isMath()" eAi
_{${1:${VISUAL}}}$0
endsnippet

snippet ^^ "superscript" "isMath()" eAi
^{${1:${VISUAL}}}$0
endsnippet

snippet tt "text" "isMath()" weA
\text{${1:${VISUAL}}}$0
endsnippet

# Binary operators

snippet xx "times" "isMath()" weA
\times
endsnippet

snippet oo "composition" "isMath()" weA
\circ
endsnippet

snippet ww "wedge product" "isMath()" weA
\wedge
endsnippet

snippet bb "box" "isMath()" weA
\Box
endsnippet

snippet cc "dot product" "isMath()" Awe
\cdot
endsnippet

snippet ss "hodge star" "isMath()" Awe
\star
endsnippet

snippet opp "direct sum" "isMath()" Awe
\oplus
endsnippet

snippet oxx "direct product" "isMath()" Awe
\otimes
endsnippet

# Summation-like symbols

snippet Oxx "big direct product" "isMath()" Awe
\bigotimes_{$1}$2
endsnippet

snippet Opp "big direct sum" "isMath()" Awe
\bigoplus_{$1}$2
endsnippet

snippet SS "summation" "isMath()" Awe
\sum_{${1:i=1}}^{${2:\infty}}$0
endsnippet

# Derivatives

snippet rdv "differentiation evaluated" "isMath()" ewA
\left.\dv[$3]{${1:${VISUAL}}}{${2:t}}\right\rvert_{$4}$0
endsnippet

snippet rpdv "partial differentiation evaluated" "isMath()" ewA
\left.\pdv[$3]{${1:${VISUAL}}}{${2:t}}\right\rvert_{$3}$0
endsnippet

snippet dv "differentiation" "isMath()" ewA
\dv{${1:${VISUAL}}}{${2:t}}$0
endsnippet

snippet "(n|\d)dv" "multiple differentiation" "isMath()" eAr
\dv[`!p snip.rv=match.group(1)`]{${1:${VISUAL}}}{${2:t}}$0
endsnippet

snippet pdv "partial differentiation" "isMath()" ewA
\frac{\partial ${1:${VISUAL:x^{\mu}}}}{\partial ${2:t}}$0
endsnippet

snippet fpdv "flat partial differentiation" "isMath()" ewA
\flatfrac{\partial ${1:${VISUAL}}}{\partial ${2:t}}$0
endsnippet

snippet fdv "functional differentiation" "isMath()" ewA
\frac{\delta ${1:${VISUAL}}}{\delta $2}$0
endsnippet

#snippet g( "single bracket" "isMath()" ewA
#(
#endsnippet

# Differentials

snippet dd "differential measure" "isMath()" Awe
\dd[${1:4}]{${2:x}}$0
endsnippet

snippet bdd "barred measure" "isMath()" ewA
\bdd[${1:4}]{${2:k}}$0
endsnippet

snippet rdd "relativistic measure" "isMath()" ewA
\frac{\bdd[3]{${1:p}}}{\sqrt{2E_{$1}}}$0
endsnippet

snippet pdd "path integral measure" "isMath()" ewA
\pdd{${1:\phi}}$0
endsnippet

snippet sqrt "square root" "isMath()" ewA
\sqrt{${1:${VISUAL}}}$0
endsnippet

snippet ind "tensor indices" "isMath()" ewA
\indices{$1}$0
endsnippet

snippet lim "limes" "isMath()" ewA
\lim_{${1:n} \to ${2:\infty}} \left\\{ $3 \right\\}
endsnippet

snippet par "differential operator" "isMath()" ewA
\partial
endsnippet

snippet nab "nabla" "isMath()" ewA
\nabla
endsnippet

snippet inf "infinity" "isMath()" eAw
\infty
endsnippet

# functions

snippet cs "cosin" "isMath()" ew
\cos($1)$0
endsnippet

snippet ch "cosin hyperbolicus" "isMath()" ew
\cosh($1)$0
endsnippet

snippet tn "tangens" "isMath()" ew
\tan($1)$0
endsnippet

snippet th "tangens hyperbolicus" "isMath()" ew
\tanh($1)$0
endsnippet

snippet sn "sin" "isMath()" ew
\sin($1)$0
endsnippet

snippet sh "sinus hyperbolicus" "isMath()" ew
\sin($1)$0
endsnippet

snippet ex "exponential" "isMath()" ew
\exp\left($1\right)$0
endsnippet

# arrows
global !p
arrows = {
  "<": "leftarrow",
  "x>": "xrightarrow",
  "Le": "Leftarrow",
  ">": "rightarrow",
  "Ri": "Rightarrow",
  "lr": "leftrightarrow",
  "Lr": "Leftrightarrow",
  "up": "uparrow",
  "Up": "Uparrow",
  "do": "downarrow",
  "Do": "Downarrow",
  "Ud": "Updownarrow",
  "ne": "nearrow",
  "nw": "nwarrow",
  "se": "searrow",
  "sw": "swarrow",
}
endglobal

priority 0
snippet "-([a-zA-Z]{1,2})" "arrows with hyphen" "isMath()" eiAr
`!p
if match.group(1) not in arrows.keys():
  snip.rv=match.group(0)
else:
  arrow=arrows[match.group(1)]
  snip.rv="\\"+arrow
`
endsnippet

snippet ( "parentheses" iA
(${1:${VISUAL}})$0
endsnippet

snippet { "braces" iA
{${1:${VISUAL}}}$0
endsnippet

snippet [ "brackets" iA
[${1:${VISUAL}}]$0
endsnippet

snippet <> "angular brackets" iA
\langle ${1:${VISUAL}} \rangle$0
endsnippet

priority 1

snippet lr( "left( right)" wA
\left( ${1:${VISUAL}} \right)
endsnippet

snippet lr| "left| right|" wA
\left| ${1:${VISUAL}} \right|
endsnippet

snippet lr{ "left\{ right\}" wA
\left\\{ ${1:${VISUAL}} \right\\}
endsnippet

snippet lr[ "left[ right]" wA
\left[ ${1:${VISUAL}} \right]
endsnippet

snippet lr< "left< right>" wA
\left\langle ${1:${VISUAL}} \right\rangle]
endsnippet

priority 50

snippet abs "absolute value" "isMath()" Aew
\abs{$1}$0
endsnippet

snippet bra "bra" "isMath()" Aew
\bra{$1}$0
endsnippet

snippet ket "ket" "isMath()" Aew
\ket{$1}$0
endsnippet

snippet can "cancel" "isMath()" Awe
\cancel{${1:${VISUAL}}}$0
endsnippet

snippet bar "bar" "isMath()" Awe
\overline{${1:${VISUAL}}}$0
endsnippet

snippet til "tilde" "isMath()" ewA
\widetilde{$1}$0
endsnippet

snippet hat "hat" "isMath()" ewA
\hat{${1:${VISUAL}}}$0
endsnippet

snippet dot "dot" "isMath()" Aew
\dot{${1:${VISUAL}}}$0
endsnippet

snippet form "set of forms" "isMath()" Awe
\Lambda^{${1:p}}(\mathcal{M})$0
endsnippet

snippet Mat "set of matrices" "isMath()" Awe 
\text{Mat}_n(F)
endsnippet

snippet det "determinant" "isMath()" e
\text{det}($1)
endsnippet

snippet :: "normal ordering" "isMath()" eiA
\normalorder{${1:${VISUAL}}}$0
endsnippet

snippet feyn "Feynman diagram" "isMath()" be
\feynmandiagram[inline=(a.base), horizontal=a to b, layered layout] {
	$1,
};$0
endsnippet

snippet loop "feynman loop" "isMath()" ew
-- [loop, min distance=2cm${1:, in=-135, out=-45}]$0
endsnippet

priority -100

snippet "(_|\^)([a-zA-Z0-9])" "sub-super swap" "isMath()" er
`!p 
indicator={"_", "^"} - {match.group(1)}
snip.rv=indicator.pop()+match.group(2)
`
endsnippet

snippet "(_|\^)({.*?})" "sub-super swap:braces" "isMath()" er
`!p 
indicator={"_", "^"} - {match.group(1)}
snip.rv=indicator.pop()+match.group(2)
`
endsnippet

snippet "(_|\^)(\\[a-z]*)" "sub-super swap: command" "isMath()" er
`!p 
indicator={"_", "^"} - {match.group(1)}
snip.rv=indicator.pop()+match.group(2)
`
endsnippet

# --- GREEK INDICES ---

# Define allowe index letter dictionary
global !p
indices = {
  "a": "\\alpha",
  "b": "\\beta",
  "c": "\\chi",
  "d": "\\delta",
  "D": "\\Delta",
  "e": "\\epsilon",
  "ve": "\\varepsilon",
  "f": "\\phi",
  "F": "\\Phi",
  "vf": "\\varphi",
  "g": "\\gamma",
  "G": "\\Gamma",
  "h": "\\eta",
  "i": "\\iota",
  "k": "\\kappa",
  "l": "\\lambda",
  "L": "\\Lambda",
  "m": "\\mu",
  "n": "\\nu",
  "o": "\\omicron",
  "p": "\\pi",
  "P": "\\Pi",
  "r": "\\rho",
  "vr": "\\varrho",
  "s": "\\sigma",
  "S": "\\Sigma",
  "t": "\\tau",
  "w": "\\omega",
  "W": "\\Omega",
  "x": "\\xi",
  "X": "\\Xi",
  "u": "\\upsilon",
  "U": "\\Upsilon",
  "z": "\\zeta",
  "y": "\\psi",
  "Y": "\\Psi",
  "q": "\\theta",
  "Q": "\\Theta",
  "vq": "\\vartheta",
  "+": "\\dagger",  # Hermitian conjugate
  "-": "-1",  # inverse
  "(": "(",
  ")": ")",
  "[": "[",
  "]": "]",
  "|": "|",
  ";": ";",
  ",": ",",
  "'": "'",
}
endglobal

priority 49
# greek and other indices with '.'
snippet "\.([a-zA-Z\[\]\(\),;+-\|]{1,2})" "indices with dot" "isMath()" eiAr
`!p
if match.group(1) not in indices.keys():
  snip.rv=match.group(0)
else:
  snip.rv="^{"+indices[match.group(1)]+"}"
`
endsnippet

priority 50
# tensor indices with '..'
snippet "\.{2}([a-zA-Z\[\]\(\),;+-\|]{1,2})" "indices with dot" "isMath()" eiAr
\indices{^{`!p
if match.group(1) not in indices.keys():
  snip.rv=match.group(0)
else:
  snip.rv=indices[match.group(1)]
`}$1}$0
endsnippet

priority 51
#higher prority than "multi indices"
snippet "(\^|_)({.*)(,|;)};" "switch partial covariant derivative" "isMath()" eiAr
`!p
indicator={",", ";"} - {match.group(3)}
snip.rv=match.group(1)+match.group(2)+indicator.pop()+"}"
`
endsnippet

priority 50
# add greek letters: {\mu}n -> {\mu\nu}
# add derivatives: {\mu},r -> {\mu,\rho}
# added primes
snippet "(\^|_)({.*?)(,|;|\\[a-z]*?|\[|\]|\|)}([a-zA-Z\[\];\|']{1,2})" "multi indices" "isMath()" eiAr
`!p
# check if new thing is a valid index
# If not, just return the whole match
# i.e. do not change anything
if match.group(4) not in indices.keys() or match.group(3) not in indices.values():
  snip.rv=match.group(0)
else:
  index=indices[match.group(4)]

  # insert new index letter into the braces
  snip.rv= match.group(1)+ match.group(2) + match.group(3) + index + "}"
`
endsnippet

# Latin indices with ','
# priority higher than greek indices

priority 51
snippet ',([a-zA-Z])' "latin index" "isMath()" eAir
`!p snip.rv = "^{"+match.group(1)+"}"`
endsnippet

priority 52
snippet ',,([a-zA-Z])' "latin tensor" "isMath()" eAir
`!p snip.rv = "\indices{^{"+match.group(1)`}$1}$0
endsnippet

snippet "(\_|\^)({[a-zA-Z']*?)}([a-zA-Z]|')" "multi latin index" "isMath()" eAir
`!p snip.rv = match.group(1) + match.group(2) + match.group(3) + "}"`
endsnippet

priority 50

# math fonts
snippet BS "boldsymbol" "isMath()" Awe
\boldsymbol
endsnippet

snippet '([1A-Z])BB' "Blackboard Bold" "isMath()" eArw
\mathbb{`!p snip.rv = match.group(1)`}
endsnippet

snippet '[a-zA-Z]CAL' "CALligraphic" "isMath()" erA
\mathcal{`!p snip.rv=match.group(0)[0]`}
endsnippet

snippet '[a-zA-Z]SCR' "Super CuRly" "isMath()" erA
\mathscr{`!p snip.rv=match.group(0)[0]`}
endsnippet

snippet '[a-zA-Z]fr' "Fraktur" "isMath()" erA
\mathfrak{`!p snip.rv=match.group(0)[0]`}
endsnippet

snippet '[a-zA-Z]til' "Tilde" "isMath()" erA
\tilde{`!p snip.rv=match.group(0)[0]`}
endsnippet

snippet '[a-zA-Z]hat' "Hat" "isMath()" erAw
\hat{`!p snip.rv=match.group(0)[0]`}
endsnippet

snippet '([a-zA-Z]{1,2})LA' "Lie Algebra" "isMath()" erA
\mathfrak{`!p snip.rv=match.group(1)`}${2:_{\mathbb{C}}}(${1:\mathcal{M}})$0
endsnippet

snippet | "such that" "isMath()" eAw
\suchthat
endsnippet

# --- GILLES CASTEL ---
snippet => "implies" Ai
\implies
endsnippet

snippet =< "implied by" Ai
\impliedby
endsnippet

snippet mk "Math" wA
$${1}$`!p
if t[2] and t[2][0] not in [',', '.', '?', '-', ' ']:
	snip.rv = ' '
else:
	snip.rv = ''
`$0
endsnippet

snippet '((\d+)|(\d*)(\\)?([A-Za-z]+)((\^|_)(\{\d+\}|\d))*)/' "Fraction" wrA
\\frac{`!p snip.rv = match.group(1)`}{$1}$0
endsnippet


priority -100
snippet '(.)([a-zA-Z]|}|\))(\d)' "Auto Index" "isMath()" eAr
`!p 
# The following line prevents \c1 -> \c_1 for simpler-wick
if match.group(1) == "\\":
  snip.rv=match.group(0)
else:
  snip.rv = match.group(1) + match.group(2) + "^" + match.group(3)`
endsnippet

priority 50

snippet '([a-zA-Z])_(\d\d)' "Auto Multi Index" "isMath()" eAwr
`!p snip.rv = match.group(1) + "^{" + match.group(2) + "}"`
endsnippet

snippet "([a-zA-Z0])(,\.|\.,)" "Vector postfix" "isMath()" eriA
\vb{`!p snip.rv=match.group(1)`}
endsnippet

